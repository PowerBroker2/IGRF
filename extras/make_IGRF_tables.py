import numpy as np
import datetime
import pandas as pd
import ppigrf
from pathlib import Path


def generate_igrf_tables(date, altitude_m, resolution_deg):
    '''
    Generate IGRF magnetic field tables on a latitude/longitude grid.

    Poles (±90°) are excluded due to spherical harmonic singularities.
    '''

    # ---- Robust date handling ----
    if isinstance(date, datetime.date) and not isinstance(date, datetime.datetime):
        date = datetime.datetime.combine(date, datetime.time())

    date = pd.Timestamp(date)

    # ---- Latitude / Longitude grid (poles removed) ----
    lats = np.arange(-90.0 + resolution_deg, 90.0, resolution_deg)
    lons = np.arange(-180.0, 180.0 + resolution_deg, resolution_deg)

    lat_grid, lon_grid = np.meshgrid(lats, lons, indexing='ij')

    # ---- Altitude (meters → km) ----
    altitude_km = altitude_m * 1e-3

    # ---- Compute magnetic field (nT) ----
    # ppigrf returns North-East-Down (NED)
    Be, Bn, Bu = ppigrf.igrf(
        lon_grid,
        lat_grid,
        altitude_km,
        date
    )

    # ---- Remove singleton dimension ----
    Bn =  np.squeeze(Bn)
    Be =  np.squeeze(Be)
    Bd = -np.squeeze(Bu)

    # ---- Defensive cleanup ----
    Bn[np.isnan(Bn)] = 0.0
    Be[np.isnan(Be)] = 0.0
    Bd[np.isnan(Bd)] = 0.0

    # ---- Field magnitude ----
    Bmag = np.sqrt(Bn**2 + Be**2 + Bd**2)

    # ---- Declination (rad → deg) ----
    # decl = atan2(East, North)
    declination = np.degrees(np.arctan2(Be, Bn))

    # ---- Inclination / Dip (rad → deg) ----
    # incl = atan2(Down, Horizontal)
    Bh = np.sqrt(Bn**2 + Be**2)
    inclination = np.degrees(np.arctan2(Bd, Bh))

    return {
        'date': date,
        'altitude_m': altitude_m,
        'resolution_deg': resolution_deg,
        'lats': lats,
        'lons': lons,
        'Bn': Bn,
        'Be': Be,
        'Bd': Bd,
        'Bmag': Bmag,
        'declination': declination,
        'inclination': inclination,
    }


def cpp_array(name, arr, dtype='float'):
    '''Convert NumPy array to C++ array string (1D or 2D).'''

    if arr.ndim == 1:
        elems = ', '.join(f'{x:.6f}f' for x in arr)
        return f'static const {dtype} {name}[{arr.size}] = {{ {elems} }};\n\n'

    if arr.ndim == 2:
        rows, cols = arr.shape
        lines = []
        for r in range(rows):
            row = ', '.join(f'{x:.6f}f' for x in arr[r])
            lines.append(f'    {{ {row} }}')
        body = ',\n'.join(lines)
        return (
            f'static const {dtype} {name}[{rows}][{cols}] = {{\n'
            f'{body}\n'
            f'}};\n\n'
        )

    raise ValueError('Only 1D or 2D arrays supported')


def write_cpp_header(filename, data):
    '''Write IGRF tables to a C++ header file.'''

    path = Path(filename)

    # ---- Extract date metadata ----
    date = data['date']
    year  = int(date.year)
    month = int(date.month)
    day   = int(date.day)

    with open(path, 'w', encoding='utf-8') as f:
        f.write('// ------------------------------------------------------------\n')
        f.write('// AUTO-GENERATED FILE — DO NOT EDIT\n')
        f.write('// Generated by make_IGRF_tables.py\n')
        f.write('// ------------------------------------------------------------\n\n')
        f.write('#pragma once\n\n')

        f.write('// Model metadata\n')
        f.write(f'static const int   IGRF_YEAR  = {year};\n')
        f.write(f'static const int   IGRF_MONTH = {month};\n')
        f.write(f'static const int   IGRF_DAY   = {day};\n')
        f.write(f'static const float IGRF_ALTITUDE_M = {data["altitude_m"]:.1f}f;\n')
        f.write(f'static const float IGRF_RESOLUTION_DEG = {data["resolution_deg"]:.1f}f;\n')
        f.write(f'static const int   IGRF_NUM_LATS = {data["lats"].size};\n')
        f.write(f'static const int   IGRF_NUM_LONS = {data["lons"].size};\n\n')

        f.write('// Latitude and longitude grids (degrees)\n')
        f.write(cpp_array('IGRF_LATS', data['lats']))
        f.write(cpp_array('IGRF_LONS', data['lons']))

        f.write('// Magnetic field components (NED, nanoTesla)\n')
        f.write(cpp_array('IGRF_BN', data['Bn']))
        f.write(cpp_array('IGRF_BE', data['Be']))
        f.write(cpp_array('IGRF_BD', data['Bd']))

        f.write('// Magnetic field magnitude (nanoTesla)\n')
        f.write(cpp_array('IGRF_BMAG', data['Bmag']))

        f.write('// Magnetic declination (degrees, East positive)\n')
        f.write(cpp_array('IGRF_DECLINATION_DEG', data['declination']))

        f.write('// Magnetic inclination / dip (degrees, Down positive)\n')
        f.write(cpp_array('IGRF_INCLINATION_DEG', data['inclination']))

    print(f'IGRF header written to: {path.resolve()}')


if __name__ == '__main__':
    from os.path import realpath, dirname, join

    date = datetime.datetime(2026, 1, 1)
    altitude_m = 0.0
    resolution_deg = 10.0

    data = generate_igrf_tables(date, altitude_m, resolution_deg)

    write_cpp_header(
        filename=join(
            dirname(dirname(realpath(__file__))),
            'src',
            'IGRF_LUTs.h'
        ),
        data=data
    )
